# Лабораторна робота: Принципи програмування. DRY, KISS, SOLID, YAGNI та ін.


Цей документ описує, як у проекті дотримуються основні принципи програмування, у тому числі SOLID та інші.

---
### Архітектура

- **MVC**:
    - `Models` (`App/models/`) — містять бізнес-логіку і моделі даних (товари, гроші, склад, звітність, логування).
    - `Views` (`App/views/`) — відповідають за відображення інформації (тут — простий показ логів).
    - `Controllers` (`App/controllers/`) — опрацьовують вхідні запити, взаємодіють з моделями та передають дані у в'ю.

- **Інтерфейси** (`App/interfaces/`) — задають контракти для моделей, забезпечуючи слабке зв’язування.

### Основні класи та їх функції

- `Money` — клас для зручної роботи з грошовими сумами (ціла і дробова частина).
- `Product` — товар із назвою і ціною (обʼєкт `Money`).
- `Warehouse` — склад, де можна додавати або знімати товари.
- `Reporting` — генерація звітів по доходах та залишках складу.
- `Logger` — збір логів роботи системи з можливістю збереження у файл.
- `ProductController` — контролер, що керує логікою створення товарів, складу та звітів, збирає логи та відображає їх у вʼю.

### Параметри та взаємодія

- Об'єкти передаються між класами через конструктори або методи, що приймають інтерфейси:
    - `Reporting` приймає у конструктор `IWarehouse` — це дає змогу підмінити реалізацію складу.
    - `Product` отримує `IMoney` для ціни.
    - `Warehouse` працює з `IProduct` — що дозволяє додавати будь-який товар, який реалізує цей інтерфейс.

- Контролер створює екземпляри моделей, керує їх взаємодією, формує логи та відображає результат у вигляді HTML.

### Використані патерни проектування

- **MVC (Model-View-Controller)** — розподіл коду за відповідальністю для полегшення підтримки та тестування.
- **Dependency Injection** — передача залежностей (інтерфейсів і моделей) у конструктори класів, що підвищує гнучкість і тестованість.
- **Composition over Inheritance** — класи складаються з обʼєктів інших класів, а не наслідують їх без потреби.
- **Interface Segregation and Programming to Interfaces** — робота з інтерфейсами замість конкретних класів для зменшення зв’язності.

---
## 1. DRY (Don't Repeat Yourself)

- Код у моделях (`App/models/`) використовує інтерфейси (`App/interfaces/`) для уніфікованої роботи з різними об'єктами.
- Логіка роботи з грошима зосереджена у класі `Money` (`App/models/Money.php`), повторне використання запобігає дублюванню.
- Контролер `ProductController` (`App/controllers/ProductController.php`) централізує роботу з товарами, складами, звітністю і логуванням.

Посилання:
- [Money.php, рядки 7-32](App/models/Money.php)
- [ProductController.php, рядки 10-70](App/controllers/ProductController.php)

---

## 2. KISS (Keep It Simple, Stupid)

- Класи мають чіткі і прості відповідальності (Single Responsibility).
- Методи мають короткий, зрозумілий функціонал, без складних залежностей.
- Приклад: метод `addProduct` класу `Warehouse` (`app/models/Warehouse.php`) додає товар до складу простим чином.

Посилання:
- [Warehouse.php, рядки 15-40](App/models/Warehouse.php)
- [ProductController.php, метод index()](App/controllers/ProductController.php#L20-L70)

---

## 3. SOLID

### Single Responsibility Principle (SRP)

- Кожен клас має одну відповідальність:
    - `Logger` — логування,
    - `Money` — робота з грошовими значеннями,
    - `Product` — модель товару,
    - `Warehouse` — управління складом,
    - `Reporting` — генерація звітів.

Посилання:
- [Logger.php, рядки 7-40](App/models/Logger.php)
- [Product.php, рядки 10-50](App/models/Product.php)

### Open/Closed Principle (OCP)

- Класи відкриті для розширення (через інтерфейси), але закриті для модифікації.
- Наприклад, інтерфейс `IReport` (`app/interfaces/IReport.php`) дозволяє додавати нові види звітів, не змінюючи клас `Reporting`.

Посилання:
- [IReport.php](App/interfaces/IReport.php)
- [Reporting.php](App/models/Reporting.php)

### Liskov Substitution Principle (LSP)

- Класи реалізують інтерфейси, що гарантує заміну базових типів на похідні без порушення логіки.
- Наприклад, `Product` реалізує `IProduct`, `Money` — `IMoney`.

Посилання:
- [Product.php](App/models/Product.php)
- [Money.php](App/models/Money.php)

### Interface Segregation Principle (ISP)

- Інтерфейси розбиті на невеликі та спеціалізовані (`IMoney`, `IProduct`, `IWarehouse`, `IReport`), що дозволяє класам реалізувати лише потрібні методи.

Посилання:
- Всі інтерфейси у `app/interfaces/`

### Dependency Inversion Principle (DIP)

- Високорівневі модулі залежать від абстракцій (інтерфейсів), а не від конкретних реалізацій.
- Наприклад, `Reporting` приймає `IWarehouse` в конструкторі, а не конкретний клас `Warehouse`.

Посилання:
- [Reporting.php, рядки 10-30](App/models/Reporting.php)

---

## 4. YAGNI (You Aren't Gonna Need It)

- Код мінімалістичний, без зайвих функцій. Всі методи використовуються за призначенням.
- Наприклад, `ProductController` виконує лише потрібні дії для демонстрації логіки.

Посилання:
- [ProductController.php](App/controllers/ProductController.php)

---

## 5. Composition Over Inheritance

- Замість складної ієрархії наслідування використовується композиція.
- Наприклад, клас `Product` має об'єкт `IMoney` (цінність) як властивість.
- Звітність отримує склад через інтерфейс `IWarehouse`.

Посилання:
- [Product.php, рядки 12-28](App/models/Product.php)
- [Reporting.php, рядки 10-30](App/models/Reporting.php)

---

## 6. Program to Interfaces, Not Implementations

- Всі залежності задаються через інтерфейси (`IMoney`, `IProduct`, `IWarehouse`, `IReport`), що підвищує гнучкість і тестованість.
- Наприклад, `Warehouse` приймає `IProduct`, а не конкретний клас `Product`.

Посилання:
- [Warehouse.php](App/models/Warehouse.php)
- [Reporting.php](App/models/Reporting.php)

---

## 7. Fail Fast

- Класи намагаються виявити помилки якомога раніше, наприклад, метод `removeProduct` у `Warehouse` повертає `false`, якщо продукту немає або кількість недостатня, що дозволяє швидко реагувати.
- Використання типів та строгих підписів методів допомагає уникнути неочікуваних помилок.

Посилання:
- [Warehouse.php, метод removeProduct](App/models/Warehouse.php#L22-L35)

---

# Висновок

Цей проект демонструє базові принципи якісного програмування: розподіл відповідальності, використання інтерфейсів, гнучкість і простоту підтримки коду. Детальний опис із посиланнями допомагає легко орієнтуватись у реалізації.

---

